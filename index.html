// functions/telegram.js
const { getKV, setKV } = require('./supabase');

const JSON_HEADERS = { 'content-type': 'application/json' };

// Admins : ADMIN_IDS (plusieurs IDs s√©par√©s par virgule) ou fallback ADMIN_CHAT_ID
const ADMIN_IDS = (process.env.ADMIN_IDS || process.env.ADMIN_CHAT_ID || '')
  .split(',')
  .map(x => x.trim())
  .filter(Boolean);
const isAdmin = id => ADMIN_IDS.includes(String(id));

// ---------- Utils Telegram ----------
async function tgFetch(method, body, TOKEN) {
  const r = await fetch(`https://api.telegram.org/bot${TOKEN}/${method}`, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(body)
  });
  const text = await r.text().catch(() => '');
  let json = null;
  try { json = JSON.parse(text); } catch {}
  return { ok: r.ok, status: r.status, text, json };
}
async function sendMsg(TOKEN, chatId, text, extra = {}) {
  return tgFetch('sendMessage', { chat_id: chatId, text, parse_mode: 'Markdown', ...extra }, TOKEN);
}
async function answerCb(TOKEN, cbId, text = '') {
  return tgFetch('answerCallbackQuery', { callback_query_id: cbId, text, show_alert: false }, TOKEN);
}

// ---------- UI clavier principal ----------
function mainKeyboard() {
  return {
    reply_markup: {
      keyboard: [
        ['‚ûï Ajouter', 'üìù Modifier', 'üóëÔ∏è Supprimer'],
        ['üîë Code d\'acc√®s', 'üè† Message bienvenue', '‚ÑπÔ∏è Info & consignes']
      ],
      resize_keyboard: true,
      one_time_keyboard: false
    }
  };
}
async function showMainMenu(TOKEN, chatId) {
  await sendMsg(TOKEN, chatId, 'Que veux-tu faire ?', mainKeyboard());
}

// ---------- Wizard produit (effet + ar√¥me inclus) ----------
const productSteps = [
  { key: 'name',   ask: v => `Envoie le *NOM* du produit${v ? ` (ou /skip pour garder "${v}")` : ''}` },
  { key: 'cat',    ask: v => `Cat√©gorie ?${v ? ` (ou /skip pour garder "${v}")` : ''}` },
  { key: 'desc',   ask: v => `Description ?${v ? ` (ou /skip pour garder "${v}")` : ''}` },
  { key: 'effet',  ask: v => `Effet ?${v ? ` (ou /skip pour garder "${v}")` : ''}` },
  { key: 'arome',  ask: v => `Ar√¥me ?${v ? ` (ou /skip pour garder "${v}")` : ''}` },
  { key: 'thclvl', ask: v => `Taux THC (%) ?${v ? ` (ou /skip pour garder "${v}")` : ''}` },
  { key: 'prices', ask: v => `Prix (format : 1g:10,2g:18)\n${Array.isArray(v) && v.length ? `Valeur actuelle : ${v.map(x => x.qte + ':' + x.price).join(', ')}` : ''}\nEnvoie ou /skip pour garder.` },
  { key: 'img',    ask: v => `URL image ? (ou /skip pour garder "${v || '(aucune)'}")` },
  { key: 'video',  ask: v => `URL vid√©o ? (ou /skip pour garder "${v || '(aucune)'}")` },
];

// ---------- Inline (√©diter / supprimer) ----------
function inlineEditRow(idx) {
  return { reply_markup: { inline_keyboard: [[{ text: '‚úèÔ∏è Modifier', callback_data: `edit_${idx}` }]] } };
}
function inlineDeleteRow(idx) {
  return { reply_markup: { inline_keyboard: [[{ text: 'üóëÔ∏è Supprimer', callback_data: `delete_${idx}` }]] } };
}
function inlineConfirmDelete(idx) {
  return {
    reply_markup: {
      inline_keyboard: [[
        { text: '‚ùå Annuler',   callback_data: 'cancel_del' },
        { text: '‚úÖ Confirmer', callback_data: `confirmdel_${idx}` }
      ]]
    }
  };
}

// ========== HANDLER ==========
exports.handler = async (event) => {
  try {
    const m = event.httpMethod;
    if (m === 'HEAD')    return { statusCode: 200, headers: JSON_HEADERS };
    if (m === 'OPTIONS') return { statusCode: 204, headers: JSON_HEADERS, body: '' };
    if (m !== 'POST')    return { statusCode: 405, headers: JSON_HEADERS, body: JSON.stringify({ error: 'Method not allowed' }) };

    const TOKEN = process.env.BOT_TOKEN;
    if (!TOKEN) return { statusCode: 500, headers: JSON_HEADERS, body: JSON.stringify({ error: 'Missing BOT_TOKEN' }) };

    let update;
    try { update = JSON.parse(event.body || '{}'); }
    catch { return { statusCode: 400, headers: JSON_HEADERS, body: JSON.stringify({ error: 'Bad JSON' }) }; }

    // ----- CALLBACK QUERY (inline) -----
    if (update.callback_query) {
      const cb = update.callback_query;
      const chatId = cb.message?.chat?.id;
      const data = cb.data || '';
      await answerCb(TOKEN, cb.id);

      if (!isAdmin(chatId)) {
        await sendMsg(TOKEN, chatId, '‚õî Acc√®s admin requis.');
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }

      let menu = (await getKV('menu')) || [];

      if (data.startsWith('delete_')) {
        const idx = parseInt(data.split('_')[1], 10);
        if (!menu[idx]) {
          await sendMsg(TOKEN, chatId, 'Produit introuvable.');
        } else {
          await sendMsg(TOKEN, chatId, `‚ö†Ô∏è Supprimer "*${menu[idx].name}*" ?`, inlineConfirmDelete(idx));
        }
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }

      if (data === 'cancel_del') {
        await sendMsg(TOKEN, chatId, 'Suppression annul√©e.');
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }

      if (data.startsWith('confirmdel_')) {
        const idx = parseInt(data.split('_')[1], 10);
        if (!menu[idx]) {
          await sendMsg(TOKEN, chatId, 'Produit introuvable.');
        } else {
          const name = menu[idx].name || '(sans nom)';
          menu.splice(idx, 1);
          await setKV('menu', menu);
          await sendMsg(TOKEN, chatId, `‚úÖ Produit "*${name}*" supprim√© !`);
        }
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }

      if (data.startsWith('edit_')) {
        const idx = parseInt(data.split('_')[1], 10);
        if (!menu[idx]) {
          await sendMsg(TOKEN, chatId, 'Produit introuvable.');
        } else {
          const stateKey = `state:${chatId}`;
          await setKV(stateKey, { mode: 'add', submode: 'edit', idx, step: 0, prod: { ...menu[idx] } });
          const first = productSteps[0];
          await sendMsg(TOKEN, chatId, `Modification "*${menu[idx].name}*"\n${first.ask(menu[idx].name)}`);
        }
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }

      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // ----- MESSAGE -----
    const msg = update.message;
    const chatId = msg?.chat?.id;
    const txt = (msg?.text || '').trim();

    if (!chatId) return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };

    // publique
    if (txt === '/whoami') {
      await sendMsg(TOKEN, chatId, `Votre chat_id: \`${chatId}\``, mainKeyboard());
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // admin only
    if (!isAdmin(chatId)) {
      await sendMsg(TOKEN, chatId, '‚õî Acc√®s admin requis.');
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // donn√©es
    const stateKey = `state:${chatId}`;
    let state = (await getKV(stateKey)) || { mode: null, step: 0, prod: null };
    let menu = (await getKV('menu')) || [];
    let conf = (await getKV('site_config')) || { access_code: '1234', welcome: '', info: '' };

    // accueil
    if (txt === '/start' || txt === '/help') {
      await showMainMenu(TOKEN, chatId);
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // ===== Boutons du menu principal =====
    if (txt === '‚ûï Ajouter') {
      state = { mode: 'add', submode: 'create', step: 0, prod: { prices: [] } };
      await setKV(stateKey, state);
      const s = productSteps[0];
      await sendMsg(TOKEN, chatId, s.ask(''), mainKeyboard());
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    if (txt === 'üìù Modifier') {
      if (!menu.length) {
        await sendMsg(TOKEN, chatId, 'Aucun produit √† modifier.', mainKeyboard());
      } else {
        for (let i = 0; i < menu.length; i++) {
          const p = menu[i];
          const line = `#${i + 1} - ${p.name || '(sans nom)'} ${p.cat ? `(${p.cat})` : ''}`;
          await sendMsg(TOKEN, chatId, line, inlineEditRow(i));
        }
      }
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    if (txt === 'üóëÔ∏è Supprimer') {
      if (!menu.length) {
        await sendMsg(TOKEN, chatId, 'Aucun produit √† supprimer.', mainKeyboard());
      } else {
        for (let i = 0; i < menu.length; i++) {
          const p = menu[i];
          const line = `#${i + 1} - ${p.name || '(sans nom)'} ${p.cat ? `(${p.cat})` : ''}`;
          await sendMsg(TOKEN, chatId, line, inlineDeleteRow(i));
        }
      }
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    if (txt === 'üîë Code d\'acc√®s') {
      state = { mode: 'config_set', key: 'access_code' };
      await setKV(stateKey, state);
      await sendMsg(TOKEN, chatId, `Code actuel : ${conf.access_code}\nEnvoie le *nouveau code* (2‚Äì16 caract√®res).`, mainKeyboard());
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    if (txt === 'üè† Message bienvenue') {
      state = { mode: 'config_set', key: 'welcome' };
      await setKV(stateKey, state);
      await sendMsg(TOKEN, chatId, `Message actuel :\n${conf.welcome || '(vide)'}\n\nEnvoie le *nouveau message de bienvenue*.`, mainKeyboard());
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    if (txt === '‚ÑπÔ∏è Info & consignes') {
      state = { mode: 'config_set', key: 'info' };
      await setKV(stateKey, state);
      await sendMsg(TOKEN, chatId, `Texte actuel :\n${conf.info || '(vide)'}\n\nEnvoie les *nouvelles infos & consignes*.`, mainKeyboard());
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // cancel
    if (txt === '/cancel' || txt === '/annuler') {
      state = { mode: null, step: 0, prod: null };
      await setKV(stateKey, state);
      await sendMsg(TOKEN, chatId, 'Annul√©.', mainKeyboard());
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // ===== Mode config_set =====
    if (state.mode === 'config_set' && state.key) {
      const key = state.key;
      if (key === 'access_code') {
        if (!/^\w{2,16}$/.test(txt)) {
          await sendMsg(TOKEN, chatId, 'Le code doit faire 2‚Äì16 caract√®res alphanum√©riques. R√©essaie ou /annuler.');
          return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
        }
      }
      conf[key] = txt;
      await setKV('site_config', conf);
      await setKV(stateKey, { mode: null, step: 0, prod: null });
      await sendMsg(TOKEN, chatId, `‚úÖ ${key} mis √† jour !`, mainKeyboard());
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // ===== Wizard d'ajout / √©dition =====
    if (state.mode === 'add') {
      const step = state.step || 0;
      const prod = state.prod || {};
      const current = productSteps[step];

      if (!current) {
        // fin
        if (state.submode === 'create') menu.push(prod);
        if (state.submode === 'edit')   menu[state.idx] = prod;
        await setKV('menu', menu);
        await setKV(stateKey, { mode: null, step: 0, prod: null });
        await sendMsg(TOKEN, chatId, state.submode === 'create' ? '‚úÖ Produit ajout√© !' : `‚úÖ Produit "${prod.name}" modifi√© !`, mainKeyboard());
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }

      if (txt !== '/skip') {
        if (current.key === 'prices') {
          prod.prices = txt
            ? txt.split(',').map(s => {
                const [qte, price] = s.split(':');
                return { qte: (qte || '').trim(), price: Number((price || '').trim()) };
              }).filter(x => x.qte && !isNaN(x.price))
            : [];
        } else if (current.key === 'thclvl') {
          const num = Number(txt);
          if (!isNaN(num)) prod.thclvl = num;
        } else {
          // name, cat, desc, effet, arome, img, video
          prod[current.key] = txt;
        }
      }

      const nextStep = step + 1;
      const next = productSteps[nextStep];
      await setKV(stateKey, { ...state, step: nextStep, prod });

      if (next) {
        const val = prod[next.key];
        const question = typeof next.ask === 'function' ? next.ask(val) : next.ask;
        await sendMsg(TOKEN, chatId, question);
      } else {
        await sendMsg(TOKEN, chatId, 'Tape /done pour enregistrer, ou /annuler pour annuler.');
      }
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    if (txt === '/done') {
      if (state.mode !== 'add' || !state.prod) {
        await sendMsg(TOKEN, chatId, 'Rien √† enregistrer. Tape "‚ûï Ajouter" pour commencer.', mainKeyboard());
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }
      const prod = state.prod;
      if (!prod.name) {
        await sendMsg(TOKEN, chatId, 'Nom manquant. /annuler pour quitter.');
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }
      if (state.submode === 'create') menu.push(prod);
      if (state.submode === 'edit')   menu[state.idx] = prod;
      await setKV('menu', menu);
      await setKV(stateKey, { mode: null, step: 0, prod: null });
      await sendMsg(TOKEN, chatId, state.submode === 'create' ? '‚úÖ Produit ajout√© !' : `‚úÖ Produit "${prod.name}" modifi√© !`, mainKeyboard());
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // ----- /menu (liste simple) -----
    if (txt === '/menu') {
      const list = menu.length
        ? menu.map((p, i) => `${i + 1}. *${p.name || '(sans nom)'}* ${p.cat ? `‚Äî ${p.cat}` : ''}`).join('\n')
        : '(vide)';
      await sendMsg(TOKEN, chatId, `Menu:\n${list}`);
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // ----- /edit N champ valeur...  (inclut effet + arome) -----
    if (txt.startsWith('/edit ')) {
      const parts = txt.split(' ');
      if (parts.length < 4) {
        await sendMsg(TOKEN, chatId, 'Format: `/edit N champ valeur...`\nchamps: name, cat, desc, effet, arome, thclvl, prices, img, video');
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }
      const n = parseInt(parts[1], 10);
      const field = parts[2];
      const value = txt.split(' ').slice(3).join(' ');
      if (!Number.isInteger(n) || n < 1 || n > menu.length) {
        await sendMsg(TOKEN, chatId, 'Index N invalide.');
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }
      const item = menu[n - 1];
      const allowed = ['name','cat','desc','effet','arome','thclvl','prices','img','video'];
      if (!allowed.includes(field)) {
        await sendMsg(TOKEN, chatId, `Champ invalide. Utilise: ${allowed.join(', ')}`);
        return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
      }
      if (field === 'thclvl') {
        const num = Number(value);
        if (isNaN(num)) {
          await sendMsg(TOKEN, chatId, 'thclvl doit √™tre un nombre (ex: 18)');
          return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
        }
        item.thclvl = num;
      } else if (field === 'prices') {
        item.prices = value
          ? value.split(',').map(x => {
              const [qte, price] = x.split(':');
              return { qte: (qte || '').trim(), price: Number(price) };
            }).filter(x => x.qte && !isNaN(x.price))
          : [];
      } else {
        item[field] = value; // name, cat, desc, effet, arome, img, video
      }
      menu[n - 1] = item;
      await setKV('menu', menu);
      await sendMsg(TOKEN, chatId, `‚úèÔ∏è √âdit√© #${n} \`${field}\`.`);
      return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };
    }

    // d√©faut : r√©affiche le menu
    await showMainMenu(TOKEN, chatId);
    return { statusCode: 200, headers: JSON_HEADERS, body: JSON.stringify({ ok: true }) };

  } catch (err) {
    return { statusCode: 500, headers: JSON_HEADERS, body: JSON.stringify({ error: 'Internal error', details: String(err?.message || err) }) };
  }
};



